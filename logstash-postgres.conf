input {
  # PostgreSQL JDBC Input - Users Table
  jdbc {
    jdbc_driver_library => "/usr/share/logstash/drivers/postgresql-42.7.1.jar"
    jdbc_driver_class => "org.postgresql.Driver"
    jdbc_connection_string => "jdbc:postgresql://postgres:5432/${POSTGRES_DB}?currentSchema=public"
    jdbc_user => "${POSTGRES_USER}"
    jdbc_password => "${POSTGRES_PASSWORD}"
    
    # Schedule - run every 2 minutes
    schedule => "*/2 * * * *"
    
    # Query users table
    statement => "SELECT id, name, email, created_at FROM users ORDER BY id"
    
    # Add metadata
    add_field => { 
      "[@metadata][index]" => "postgres-users"
      "[@metadata][doc_type]" => "user"
      "data_source" => "postgresql"
    }
    
    # Tag for identification
    tags => ["postgresql", "users"]
  }
}

input {
  # Apache AGE Graph Data Input
  jdbc {
    jdbc_driver_library => "/usr/share/logstash/drivers/postgresql-42.7.1.jar"
    jdbc_driver_class => "org.postgresql.Driver"
    jdbc_connection_string => "jdbc:postgresql://postgres:5432/${POSTGRES_DB}"
    jdbc_user => "${POSTGRES_USER}"
    jdbc_password => "${POSTGRES_PASSWORD}"
    
    # Schedule - run every 5 minutes for graph queries
    schedule => "*/5 * * * *"
    
    # Query Apache AGE demo graph
    statement => "
      SELECT * FROM cypher('demo_graph', $$
        MATCH (n) 
        RETURN id(n) as node_id, 
               labels(n) as node_labels, 
               properties(n) as node_properties
      $$) AS (node_id agtype, node_labels agtype, node_properties agtype)
    "
    
    # Add metadata
    add_field => { 
      "[@metadata][index]" => "postgres-graph"
      "[@metadata][doc_type]" => "graph_node"
      "data_source" => "apache_age"
    }
    
    # Tag for identification
    tags => ["postgresql", "apache_age", "graph"]
  }
}

filter {
  # Parse Apache AGE agtype fields (JSON-like format)
  if "apache_age" in [tags] {
    ruby {
      code => '
        require "json"
        event.to_hash.each do |key, value|
          if value.is_a?(String)
            # AGE returns agtype as string, try to parse as JSON
            if value.start_with?("{") || value.start_with?("[") || value.match(/^\d+$/)
              begin
                parsed_value = JSON.parse(value) rescue value
                event.set(key, parsed_value)
              rescue JSON::ParserError
                # Keep original value if parsing fails
              end
            end
          end
        end
      '
    }
    
    # Clean up field names
    mutate {
      rename => { 
        "node_id" => "graph_node_id"
        "node_labels" => "graph_labels" 
        "node_properties" => "properties"
      }
    }
  }
  
  # Add timestamp
  mutate {
    add_field => { "ingestion_timestamp" => "%{@timestamp}" }
  }
  
  # Convert created_at to proper timestamp for users
  if [created_at] {
    date {
      match => [ "created_at", "yyyy-MM-dd HH:mm:ss.SSSSSS", "yyyy-MM-dd HH:mm:ss" ]
      target => "created_timestamp"
    }
  }
}

output {
  # Debug output (remove in production)
  stdout { 
    codec => rubydebug { metadata => true }
  }
  
  # Send to Elasticsearch
  elasticsearch {
    hosts => ["https://es01:9200"]
    user => "${ELASTIC_USER}"
    password => "${ELASTIC_PASSWORD}"
    cacert => "certs/ca/ca.crt"
    
    # Dynamic index based on metadata
    index => "%{[@metadata][index]}-%{+YYYY.MM.dd}"
    document_type => "%{[@metadata][doc_type]}"
  }
}
